---
title: 八股文TellMeWhy之Redis
createTime: 2025/06/21 19:20:25
permalink: /article/anoo9ub2/
---

# Redis5.0

OK Let's Dive in!🤿

## Redis 为什么快

### 内存操作

🔴访问内存 (DRAM) vs 访问磁盘 (SSD/HDD) 的速度差异是 100ns vs 100us vs 10ms (10 万倍差距)。这是 Redis 速度的物理基础。

⚫当数据全在内存后，瓶颈就从磁盘 I/O 变成了网络 I/O和CPU 处理能力。这也是 Redis 设计核心逻辑集中在网络和 CPU 效率优化的原因。

⚫内存掉电数据即失，引出持久化问题。

⚫内存比磁盘贵得多，限制了数据集大小。

### 单线程模型

纯单线程模型： 所有核心操作都在一个线程内完成：

- 监听网络连接 (bind, listen, accept)
- I/O 多路复用 (epoll/kqueue/select 事件循环)
- Socket 数据读写
- Redis 协议解析与请求构造
- 命令查找、参数解析、执行
- 内存数据结构操作
- 生成响应、写入 Socket
- 过期 Key 扫描（部分逻辑）
- RDB/AOF 持久化 fork 操作（bgsave, bgrewriteaof 由主线程 fork，但持久化本身在子进程）

🔴单线程模型避免了多线程的上下文切换和锁的开销。

- 锁竞争： 多线程环境下，共享数据结构需要锁保护（如全局哈希表）。锁的获取、释放、等待在高并发时消耗巨大 CPU，且极易引发性能瓶颈和复杂
  bug。
- 上下文切换： 线程数 > CPU 核数时，操作系统频繁切换线程执行，保存 / 恢复寄存器状态、更新内核数据结构等操作消耗可观 CPU 时间。
- 设计哲学：简单、高效、可控。 单线程消除了线程安全问题，让内部实现（如数据操作、事件处理）变得极其清晰和可预测。

⚫单线程吞吐量存在理论上限（取决于单核性能和网络带宽）

⚫单个命令计算不能并行加速（这是引入网络 I/O 线程的根本原因）。

⚫长命令阻塞： 任何耗时操作（如KEYS *, FLUSHALL) 或大 Key 操作（如读 / 写一个包含百万字段的
Hash），都会阻塞整个实例，导致所有后续请求延迟飙升。这是单线程模型与生俱来的问题。

- 绝对禁用 KEYS → 使用 SCAN 增量迭代。
- 避免大 Key → 拆分数据结构（如大 Hash 按字段 Hash 分桶）。
- 避免大 Value → 压缩数据（如使用 GZIP 压缩）。
- 查询优化 → HSCAN 替代 HGETALL，ZRANGE ... LIMIT 替代取全量。
- 合理使用管道 → 减少网络 RTT 次数，一次批处理多个命令，提升单线程利用率。

### I/O 多路复用(epoll)

#### 技术实现

使用 epoll 实现 I/O 多路复用，支持海量连接。同时也是目前 Linux 上最高效的 I/O 多路复用机制。它提供了三个关键系统调用：

1. epoll_create：创建一个 epoll 实例，返回一个文件描述符(fd)指向内核中的 epoll 实例。。
2. epoll_ctl(epfd, op, fd, event)：向 epoll 实例添加、修改或删除文件描述符。（ 在连接生命周期中调用次数少，只在 fd
   状态改变时调用，如新连接加入、修改监听事件、关闭连接时删除 ）
    - epfd：epoll_create 返回的 fd。
    - op：操作类型（EPOLL_CTL_ADD 添加，EPOLL_CTL_MOD 修改，EPOLL_CTL_DEL 删除）。
    - fd：要操作的 Socket fd。
    - event：关心的事件（EPOLLIN 有数据可读，EPOLLOUT 可写，EPOLLET 边缘触发模式）。
3. epoll_wait(epfd, events, maxevents, timeout)：等待文件描述符上的事件。
    - epfd：epoll 实例 fd。
    - events：一个数组，由 epoll_wait 填充发生的事件（哪些 fd 有需求）。
    - maxevents：events 数组的大小（一次最多拿多少通知）。
    - timeout：超时时间（最多等多久，-1 表示无限等待）。
    - 返回值： 就绪事件列表。
    - 核心优势： 内核将就绪事件列表通过 events 直接返回给用户空间。避免全量扫描 fd 集合，复杂度 O (1) 或 O (就绪的 fd 数)。

#### 触发模式

##### 水平触发 (Level-Triggered, LT) - Redis 5.0 默认

只要 fd 满足监听的条件（如接收缓冲区有数据未读完），每次调用 epoll_wait 都会通知。

🔴编码简单安全。应用程序只需关心读 / 写操作即可，不用一次性处理完所有数据。

⚫可能会多次通知同一个事件（如果程序不处理完）。

##### 边缘触发 (Edge-Triggered, ET)

只在 fd 状态变化时通知一次（如接收缓冲区从空变为非空）。后续即使缓冲区还有数据未读完，只要没有新数据到达（状态再次变化），就不再通知。

🔴理论上通知次数更少，性能略优。

⚫编程复杂度高， 应用必须在收到通知后，非阻塞地循环读 / 写 Socket，直到系统调用返回 EAGAIN 或
EWOULDBLOCK（表示暂时没有数据可读或发送缓冲区满），否则会遗漏事件。 更容易出错，可能导致数据读取不全或饿死（忘记处理导致认为
fd 没事了）。

#### 高效内核

1. 红黑树 (Red-Black Tree)
    - 内核用红黑树组织 epoll_ctl 注册的所有 fd（高效支持 ADD, MOD, DEL 操作，O (log n)）。
    - 解决 select/poll 中内核需线性扫描的问题。
2. 就绪链表 (Ready List)
    - 当 fd 状态变化（有事件就绪）时，内核中断处理程序将其插入一个就绪链表中（而不是立即通知用户）。
    - epoll_wait 只需检查这个链表是否有节点即可（近乎 O (1)）。
3. 回调机制 (Callback)
    - 内核为每个注册的 fd 关联一个回调函数。
    - 当 fd 的 I/O 状态发生变化时（如网卡数据到达填入接收缓冲区），中断处理会触发回调函数。
    - 回调函数的工作：检查这个变化是否让 fd 产生了我们关心的事件？如果是，就把该 fd 插入就绪链表。

### 数据结构

Redis 5.0 的数据结构优化已基本成熟。以下机制是其性能关键：

#### 字符串 (String): Simple Dynamic String (SDS)

## 持久化机制

## 过期键删除策略

## 内存淘汰策略

## 主从复制原理

## Sentinel 高可用

## Cluster 集群分片

## 底层数据结构实现

## 缓存问题经典三问

## 分布式锁