---
title: 八股文TellMeWhy之Redis
createTime: 2025/06/21 19:20:25
permalink: /article/anoo9ub2/
---

# Redis

OK Let's Dive in!🤿

## Redis 为什么快

### 内存操作

🔴访问内存 (DRAM) vs 访问磁盘 (SSD/HDD) 的速度差异是 100ns vs 100us vs 10ms (10 万倍差距)。这是 Redis 速度的物理基础。

⚫当数据全在内存后，瓶颈就从磁盘 I/O 变成了网络 I/O和CPU 处理能力。这也是 Redis 设计核心逻辑集中在网络和 CPU 效率优化的原因。

⚫内存掉电数据即失，引出持久化问题。

⚫内存比磁盘贵得多，限制了数据集大小。

### 单线程模型

🔴单线程模型避免了多线程的上下文切换和锁的开销。

- 锁竞争： 多线程环境下，共享数据结构需要锁保护（如全局哈希表）。锁的获取、释放、等待在高并发时消耗巨大 CPU，且极易引发性能瓶颈和复杂 bug。
- 上下文切换： 线程数 > CPU 核数时，操作系统频繁切换线程执行，保存 / 恢复寄存器状态、更新内核数据结构等操作消耗可观 CPU 时间。
- 设计哲学：简单、高效、可控。 单线程消除了线程安全问题，让内部实现（如数据操作、事件处理）变得极其清晰和可预测。

⚫单个命令计算不能并行加速（这是引入网络 I/O 线程的根本原因）。

⚫长命令阻塞： 任何耗时操作（如KEYS *, FLUSHALL) 或大 Key 操作（如读 / 写一个包含百万字段的 Hash），都会阻塞整个实例，导致所有后续请求延迟飙升。这是单线程模型与生俱来的问题。

### I/O 多路复用

## 持久化机制

## 过期键删除策略

## 内存淘汰策略

## 主从复制原理

## Sentinel 高可用

## Cluster 集群分片

## 底层数据结构实现

## 缓存问题经典三问

## 分布式锁