import{_ as a,c as n,a as p,o as e}from"./app-pBrtxVLr.js";const c={};function l(i,s){return e(),n("div",null,[...s[0]||(s[0]=[p(`<hr><h2 id="_1-组件是什么" tabindex="-1"><a class="header-anchor" href="#_1-组件是什么"><span>1. 组件是什么</span></a></h2><p>在 React 里，组件（Component）是 UI 的最小可复用单元。你可以把页面看成组件树：</p><ul><li>页面组件负责整体结构</li><li>业务组件负责某个功能块</li><li>通用组件负责复用能力（弹窗、表格、按钮、加载态等）</li></ul><p>组件化的意义是：拆分复杂度、提高复用率、降低维护成本。</p><h3 id="java-工程师可先这样理解" tabindex="-1"><a class="header-anchor" href="#java-工程师可先这样理解"><span>Java 工程师可先这样理解</span></a></h3><ul><li>React 组件 ≈ Java 里的“对象 + <code>render()</code> 方法”：输入变了就重新渲染。</li><li>JSX ≈ 模板引擎（JSP/Thymeleaf）的内联写法，但和逻辑代码写在一起。</li><li><code>props</code> ≈ 方法参数/构造参数：由外部传入，组件内部只读。</li><li><code>state</code> ≈ 对象内部字段：但必须通过 <code>setState</code>（如 <code>setCount</code>）更新，才能驱动 UI 刷新。</li><li><code>useEffect</code> ≈ 生命周期回调 + 资源清理（可类比 <code>@PostConstruct</code> + <code>@PreDestroy</code>）。</li></ul><hr><h2 id="_2-为什么函数式组件是主流" tabindex="-1"><a class="header-anchor" href="#_2-为什么函数式组件是主流"><span>2. 为什么函数式组件是主流</span></a></h2><p>React 早期常见类组件（Class Component），现在主流是函数式组件（Function Component）+ Hooks。</p><p>函数式组件的优势：</p><ol><li>代码更简洁，没有 <code>this</code> 绑定问题。</li><li>逻辑复用更自然（可抽成自定义 Hook）。</li><li>副作用与状态管理更清晰（<code>useEffect</code>、<code>useState</code> 等）。</li></ol><p>一个最小函数式组件：</p><p>在 React 17+（自动 JSX Runtime）中，通常不再需要手动 <code>import React</code>。</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>export</span><span class="space"> </span><span>function</span><span class="space"> </span><span>Hello()</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>&lt;h1&gt;你好，React&lt;/h1&gt;;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3-jsx-组件返回的-界面描述" tabindex="-1"><a class="header-anchor" href="#_3-jsx-组件返回的-界面描述"><span>3. JSX：组件返回的“界面描述”</span></a></h2><p>JSX 可以先把它理解成：<strong>“在 JavaScript 里写 HTML 外观的 UI 模板语法”</strong>。</p><p>Java 类比：</p><ul><li>JSP/Thymeleaf 是“模板文件 + 表达式”。</li><li>JSX 是“模板语法直接写在组件函数里”。</li></ul><h3 id="_3-1-jsx-到底是什么-不是字符串" tabindex="-1"><a class="header-anchor" href="#_3-1-jsx-到底是什么-不是字符串"><span>3.1 JSX 到底是什么（不是字符串）</span></a></h3><p>这段：</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>const</span><span class="space"> </span><span>view</span><span class="space"> </span><span>=</span><span class="space"> </span><span>&lt;h1&gt;Hello&lt;/h1&gt;;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>不是在创建 HTML 字符串，而是在创建“元素描述对象”。 编译后会变成类似：</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>const</span><span class="space"> </span><span>view</span><span class="space"> </span><span>=</span><span class="space"> </span><span>React.createElement(&quot;h1&quot;,</span><span class="space"> </span><span>null,</span><span class="space"> </span><span>&quot;Hello&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>所以 JSX 本质是语法糖，帮助你更直观地描述 UI 结构。</p><h3 id="_3-2-里能放什么" tabindex="-1"><a class="header-anchor" href="#_3-2-里能放什么"><span>3.2 <code>{}</code> 里能放什么</span></a></h3><p><code>{}</code> 里放的是<strong>表达式</strong>，不是语句。</p><p>✅ 可以放：变量、三元表达式、函数调用结果、数组 <code>map</code> 结果。<br> ❌ 不能直接放：<code>if</code>、<code>for</code>、<code>switch</code> 这些语句。</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>const</span><span class="space"> </span><span>name</span><span class="space"> </span><span>=</span><span class="space"> </span><span>&quot;小明&quot;;</span></span>
<span class="line"><span>const</span><span class="space"> </span><span>isVip</span><span class="space"> </span><span>=</span><span class="space"> </span><span>true;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>return</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>&lt;div&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;p&gt;{name}&lt;/p&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;p&gt;{isVip</span><span class="space"> </span><span>?</span><span class="space"> </span><span>&quot;VIP</span><span class="space"> </span><span>用户&quot;</span><span class="space"> </span><span>:</span><span class="space"> </span><span>&quot;普通用户&quot;}&lt;/p&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;p&gt;{new</span><span class="space"> </span><span>Date().toLocaleDateString()}&lt;/p&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>&lt;/div&gt;</span></span>
<span class="line"><span>);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你想写 <code>if</code>，通常在 <code>return</code> 上面先算好变量，再放进 JSX。</p><h3 id="_3-3-属性写法为什么和-html-不一样" tabindex="-1"><a class="header-anchor" href="#_3-3-属性写法为什么和-html-不一样"><span>3.3 属性写法为什么和 HTML 不一样</span></a></h3><p>JSX 更接近 JavaScript 对象命名规则：</p><ul><li><code>class</code> -&gt; <code>className</code></li><li><code>for</code> -&gt; <code>htmlFor</code></li><li>事件用驼峰：<code>onclick</code> -&gt; <code>onClick</code></li><li><code>style</code> 用对象：<code>style={{ color: &quot;red&quot;, fontSize: 14 }}</code></li></ul><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>return</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>&lt;label</span><span class="space"> </span><span>htmlFor=&quot;kw&quot;</span><span class="space"> </span><span>className=&quot;search-label&quot;</span><span class="space"> </span><span>style={{ color: &quot;#333&quot; }}&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>关键词</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>&lt;/label&gt;</span></span>
<span class="line"><span>);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-4-为什么必须-单一根节点" tabindex="-1"><a class="header-anchor" href="#_3-4-为什么必须-单一根节点"><span>3.4 为什么必须“单一根节点”</span></a></h3><p>组件的 <code>return</code> 需要返回一个整体。 如果你想并列返回多个元素，用一个根包起来，或用 Fragment：</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>return</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>&lt;&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;h3&gt;标题&lt;/h3&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;p&gt;内容&lt;/p&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>&lt;/&gt;</span></span>
<span class="line"><span>);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 类比：方法返回值只能是一个对象；Fragment 相当于“逻辑容器”，不会多渲染一层真实 DOM。</p><h3 id="_3-5-一个完整、常见的-jsx-示例" tabindex="-1"><a class="header-anchor" href="#_3-5-一个完整、常见的-jsx-示例"><span>3.5 一个完整、常见的 JSX 示例</span></a></h3><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>const</span><span class="space"> </span><span>name</span><span class="space"> </span><span>=</span><span class="space"> </span><span>&quot;小明&quot;;</span></span>
<span class="line"><span>const</span><span class="space"> </span><span>tasks</span><span class="space"> </span><span>=</span><span class="space"> </span><span>[&quot;写周报&quot;,</span><span class="space"> </span><span>&quot;提测&quot;,</span><span class="space"> </span><span>&quot;代码评审&quot;];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>return</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>&lt;section&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;h3</span><span class="space"> </span><span>className=&quot;title&quot;&gt;欢迎你，{name}&lt;/h3&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;ul&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>{tasks.map((task)</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;li</span><span class="space"> </span><span>key={task}&gt;{task}&lt;/li&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>))}</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;/ul&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>&lt;/section&gt;</span></span>
<span class="line"><span>);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_3-6-jsx-常见报错速记" tabindex="-1"><a class="header-anchor" href="#_3-6-jsx-常见报错速记"><span>3.6 JSX 常见报错速记</span></a></h3><ol><li><strong>忘记闭合标签</strong>：<code>&lt;input&gt;</code> 在 JSX 中通常要写成 <code>&lt;input /&gt;</code>。</li><li><strong>返回多个平级元素未包裹</strong>：要加 <code>&lt;div&gt;</code> 或 <code>&lt;&gt;...&lt;/&gt;</code>。</li><li><strong>在 JSX 里直接写 <code>if</code></strong>：改用三元表达式，或提前在 <code>return</code> 外处理。</li></ol><hr><h2 id="_4-props-组件的输入" tabindex="-1"><a class="header-anchor" href="#_4-props-组件的输入"><span>4. Props：组件的输入</span></a></h2><p><code>props</code> 是父组件传给子组件的输入。你可以把子组件当成“根据输入返回 UI 的函数”。</p><p>Java 类比：</p><ul><li><code>props</code> ≈ 方法参数 / 构造参数</li><li>子组件 ≈ 被调用方</li><li>父组件重新传参 ≈ 再次调用方法并传入新参数</li></ul><h3 id="_4-1-最小示例-只读输入" tabindex="-1"><a class="header-anchor" href="#_4-1-最小示例-只读输入"><span>4.1 最小示例：只读输入</span></a></h3><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>type</span><span class="space"> </span><span>UserCardProps</span><span class="space"> </span><span>=</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>name:</span><span class="space"> </span><span>string;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>age?:</span><span class="space"> </span><span>number;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function</span><span class="space"> </span><span>UserCard({</span><span class="space"> </span><span>name,</span><span class="space"> </span><span>age</span><span class="space"> </span><span>=</span><span class="space"> </span><span>18</span><span class="space"> </span><span>}:</span><span class="space"> </span><span>UserCardProps)</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>&lt;div&gt;{name}</span><span class="space"> </span><span>-</span><span class="space"> </span><span>{age}&lt;/div&gt;;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子里：</p><ul><li><code>name</code> 是必填参数</li><li><code>age</code> 是可选参数</li><li><code>age = 18</code> 是默认值</li></ul><h3 id="_4-2-为什么-props-必须只读" tabindex="-1"><a class="header-anchor" href="#_4-2-为什么-props-必须只读"><span>4.2 为什么 <code>props</code> 必须只读</span></a></h3><p>React 的核心是单向数据流：<strong>父 -&gt; 子</strong>。 如果子组件直接改 <code>props</code>，会导致“数据到底由谁维护”变得混乱。</p><p>所以正确方式是：</p><ol><li>父组件维护状态</li><li>通过 <code>props</code> 传给子组件</li><li>子组件只渲染，不直接改</li></ol><h3 id="_4-3-常见实战模式-数据下行-事件上行" tabindex="-1"><a class="header-anchor" href="#_4-3-常见实战模式-数据下行-事件上行"><span>4.3 常见实战模式：数据下行 + 事件上行</span></a></h3><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>import</span><span class="space"> </span><span>{</span><span class="space"> </span><span>useState</span><span class="space"> </span><span>}</span><span class="space"> </span><span>from</span><span class="space"> </span><span>&quot;react&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type</span><span class="space"> </span><span>CounterPanelProps</span><span class="space"> </span><span>=</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>count:</span><span class="space"> </span><span>number;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>onIncrement:</span><span class="space"> </span><span>()</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>void;</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function</span><span class="space"> </span><span>CounterPanel({</span><span class="space"> </span><span>count,</span><span class="space"> </span><span>onIncrement</span><span class="space"> </span><span>}:</span><span class="space"> </span><span>CounterPanelProps)</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>&lt;button</span><span class="space"> </span><span>onClick={onIncrement}&gt;+1（当前：{count}）&lt;/button&gt;;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>export</span><span class="space"> </span><span>function</span><span class="space"> </span><span>CounterPage()</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>const</span><span class="space"> </span><span>[count,</span><span class="space"> </span><span>setCount]</span><span class="space"> </span><span>=</span><span class="space"> </span><span>useState(0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;CounterPanel</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>count={count}</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>onIncrement={()</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>setCount((prev)</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>prev</span><span class="space"> </span><span>+</span><span class="space"> </span><span>1)}</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>/&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的思路：</p><ul><li><code>count</code> 从父组件传给子组件（数据下行）</li><li>子组件触发 <code>onIncrement</code> 通知父组件（事件上行）</li><li>父组件更新状态后再把新值传下去</li></ul><p>Java 类比：父组件像 Service，子组件像调用链下游；数据向下传，回调向上抛。</p><h3 id="_4-4-typescript-下-props-的常见写法" tabindex="-1"><a class="header-anchor" href="#_4-4-typescript-下-props-的常见写法"><span>4.4 TypeScript 下 props 的常见写法</span></a></h3><ul><li>必填字段：<code>name: string</code></li><li>可选字段：<code>age?: number</code></li><li>默认值：<code>function A({ age = 18 }: Props) {}</code></li><li>回调签名：<code>onChange: (value: string) =&gt; void</code></li><li>插槽内容：<code>children: ReactNode</code></li></ul><h3 id="_4-5-两个高频误区" tabindex="-1"><a class="header-anchor" href="#_4-5-两个高频误区"><span>4.5 两个高频误区</span></a></h3><ol><li><strong>直接修改 props（错误）</strong></li></ol><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>function</span><span class="space"> </span><span>Bad({</span><span class="space"> </span><span>count</span><span class="space"> </span><span>}:</span><span class="space"> </span><span>{</span><span class="space"> </span><span>count:</span><span class="space"> </span><span>number</span><span class="space"> </span><span>})</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>//</span><span class="space"> </span><span>count</span><span class="space"> </span><span>+=</span><span class="space"> </span><span>1;</span><span class="space"> </span><span>//</span><span class="space"> </span><span>❌</span><span class="space"> </span><span>不要这样做</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>&lt;span&gt;{count}&lt;/span&gt;;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li><strong>把 props 无脑拷贝到 state</strong></li></ol><p><code>const [x, setX] = useState(props.x)</code> 只在初始化用一次，后续父组件更新 <code>props.x</code> 时，<code>x</code> 不会自动同步。</p><p>只有在你明确要“本地编辑副本”时，才考虑这样做。</p><h3 id="_4-6-一句话记忆" tabindex="-1"><a class="header-anchor" href="#_4-6-一句话记忆"><span>4.6 一句话记忆</span></a></h3><p><code>props</code> 解决的是“组件输入”；<code>state</code> 解决的是“组件内部可变状态”。</p><hr><h2 id="_5-state-组件的内部状态-usestate" tabindex="-1"><a class="header-anchor" href="#_5-state-组件的内部状态-usestate"><span>5. State：组件的内部状态（<code>useState</code>）</span></a></h2><p><code>state</code> 用于描述“会变化并触发视图更新”的数据。</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>import</span><span class="space"> </span><span>{</span><span class="space"> </span><span>useState</span><span class="space"> </span><span>}</span><span class="space"> </span><span>from</span><span class="space"> </span><span>&quot;react&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function</span><span class="space"> </span><span>Counter()</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>const</span><span class="space"> </span><span>[count,</span><span class="space"> </span><span>setCount]</span><span class="space"> </span><span>=</span><span class="space"> </span><span>useState(0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;button</span><span class="space"> </span><span>onClick={()</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>setCount((prev)</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>prev</span><span class="space"> </span><span>+</span><span class="space"> </span><span>1)}&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>点击次数：{count}</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;/button&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要点：</p><ul><li>调用 <code>setXxx</code> 会触发重新渲染。</li><li>更新依赖旧值时，用函数式更新 <code>setState(prev =&gt; ...)</code>。</li><li>不要直接改对象/数组本身，要创建新引用再更新。</li></ul><p>Java 类比：把 <code>state</code> 想成类字段没问题，但要记住 React 不是靠你“改字段”刷新页面，而是靠 <code>setXxx</code> 触发渲染流程。</p><hr><h2 id="_6-事件处理-用户交互入口" tabindex="-1"><a class="header-anchor" href="#_6-事件处理-用户交互入口"><span>6. 事件处理：用户交互入口</span></a></h2><p>React 事件名使用驼峰，如 <code>onClick</code>、<code>onChange</code>。</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>import</span><span class="space"> </span><span>{</span><span class="space"> </span><span>useState</span><span class="space"> </span><span>}</span><span class="space"> </span><span>from</span><span class="space"> </span><span>&quot;react&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function</span><span class="space"> </span><span>SearchBox()</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>const</span><span class="space"> </span><span>[keyword,</span><span class="space"> </span><span>setKeyword]</span><span class="space"> </span><span>=</span><span class="space"> </span><span>useState(&quot;&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>const</span><span class="space"> </span><span>handleSubmit</span><span class="space"> </span><span>=</span><span class="space"> </span><span>()</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>console.log(&quot;搜索词&quot;,</span><span class="space"> </span><span>keyword);</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;input</span><span class="space"> </span><span>value={keyword}</span><span class="space"> </span><span>onChange={(e)</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>setKeyword(e.target.value)}</span><span class="space"> </span><span>/&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;button</span><span class="space"> </span><span>onClick={handleSubmit}&gt;搜索&lt;/button&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;/&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要点：</p><ul><li>事件处理函数是“传函数”，不是“立即执行结果”。</li><li>表单类组件通常采用受控模式（<code>value + onChange</code>）。</li></ul><hr><h2 id="_7-渲染逻辑-条件渲染与列表渲染" tabindex="-1"><a class="header-anchor" href="#_7-渲染逻辑-条件渲染与列表渲染"><span>7. 渲染逻辑：条件渲染与列表渲染</span></a></h2><h3 id="_7-1-条件渲染" tabindex="-1"><a class="header-anchor" href="#_7-1-条件渲染"><span>7.1 条件渲染</span></a></h3><p>常见写法：</p><ul><li>三元表达式：<code>condition ? A : B</code></li><li>与运算：<code>condition &amp;&amp; A</code></li></ul><h3 id="_7-2-列表渲染" tabindex="-1"><a class="header-anchor" href="#_7-2-列表渲染"><span>7.2 列表渲染</span></a></h3><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>{list.map((item)</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>&lt;li</span><span class="space"> </span><span>key={item.id}&gt;{item.name}&lt;/li&gt;</span></span>
<span class="line"><span>))}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>key</code> 是列表 diff 的关键标识，要求：</p><ul><li>稳定</li><li>唯一</li><li>尽量使用业务 id，不建议用数组索引（尤其在可重排列表中）</li></ul><hr><h2 id="_8-副作用与-生命周期思维-useeffect" tabindex="-1"><a class="header-anchor" href="#_8-副作用与-生命周期思维-useeffect"><span>8. 副作用与“生命周期思维”（<code>useEffect</code>）</span></a></h2><p>函数式组件没有类组件生命周期函数，但可以用 <code>useEffect</code> 表达“渲染后执行副作用”的行为。</p><p>先记住一句话：<strong>依赖变更时，React 会先清理旧 effect，再执行新 effect。</strong></p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>import</span><span class="space"> </span><span>{</span><span class="space"> </span><span>useEffect,</span><span class="space"> </span><span>useState</span><span class="space"> </span><span>}</span><span class="space"> </span><span>from</span><span class="space"> </span><span>&quot;react&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>async</span><span class="space"> </span><span>function</span><span class="space"> </span><span>fetchUsers(keyword:</span><span class="space"> </span><span>string):</span><span class="space"> </span><span>Promise&lt;string[]&gt;</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>const</span><span class="space"> </span><span>resp</span><span class="space"> </span><span>=</span><span class="space"> </span><span>await</span><span class="space"> </span><span>fetch(\`/api/users?keyword=\${encodeURIComponent(keyword)}\`);</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>resp.json();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function</span><span class="space"> </span><span>UserSearch()</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>const</span><span class="space"> </span><span>[keyword,</span><span class="space"> </span><span>setKeyword]</span><span class="space"> </span><span>=</span><span class="space"> </span><span>useState(&quot;&quot;);</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>const</span><span class="space"> </span><span>[users,</span><span class="space"> </span><span>setUsers]</span><span class="space"> </span><span>=</span><span class="space"> </span><span>useState&lt;string[]&gt;([]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>useEffect(()</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>if</span><span class="space"> </span><span>(!keyword.trim())</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>setUsers([]);</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>return;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>//</span><span class="space"> </span><span>防抖：输入停止</span><span class="space"> </span><span>300ms</span><span class="space"> </span><span>后再请求</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>const</span><span class="space"> </span><span>timer</span><span class="space"> </span><span>=</span><span class="space"> </span><span>setTimeout(async</span><span class="space"> </span><span>()</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>const</span><span class="space"> </span><span>result</span><span class="space"> </span><span>=</span><span class="space"> </span><span>await</span><span class="space"> </span><span>fetchUsers(keyword);</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>setUsers(result);</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>},</span><span class="space"> </span><span>300);</span></span>
<span class="line"><span></span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>//</span><span class="space"> </span><span>清理：下次</span><span class="space"> </span><span>keyword</span><span class="space"> </span><span>变化前/组件卸载前，取消上一次等待中的任务</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>()</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>clearTimeout(timer);</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>},</span><span class="space"> </span><span>[keyword]);</span></span>
<span class="line"><span></span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;input</span><span class="space"> </span><span>value={keyword}</span><span class="space"> </span><span>onChange={(e)</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>setKeyword(e.target.value)}</span><span class="space"> </span><span>/&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;ul&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>{users.map((name)</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;li</span><span class="space"> </span><span>key={name}&gt;{name}&lt;/li&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>))}</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;/ul&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;/&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-1-逐帧执行图-以-keyword-为例" tabindex="-1"><a class="header-anchor" href="#_8-1-逐帧执行图-以-keyword-为例"><span>8.1 逐帧执行图（以 <code>[keyword]</code> 为例）</span></a></h3><table><thead><tr><th>帧</th><th>触发事件</th><th>渲染（Render）</th><th>effect（Setup）</th><th>cleanup（清理）</th></tr></thead><tbody><tr><td>F1</td><td>首次挂载</td><td><code>keyword=&quot;&quot;</code>，显示空列表</td><td>不发请求（直接返回）</td><td>无</td></tr><tr><td>F2</td><td>输入 <code>ja</code></td><td>用 <code>keyword=&quot;ja&quot;</code> 重新渲染</td><td>创建 <code>timer#1</code>（300ms 后请求）</td><td>无</td></tr><tr><td>F3</td><td>很快又输入 <code>java</code></td><td>用 <code>keyword=&quot;java&quot;</code> 再渲染</td><td>创建 <code>timer#2</code>（300ms 后请求）</td><td><strong>先清理 <code>timer#1</code></strong></td></tr><tr><td>F4</td><td>停止输入并等待</td><td>UI 保持当前输入</td><td><code>timer#2</code> 触发，请求并更新列表</td><td>无</td></tr><tr><td>F5</td><td>组件卸载</td><td>组件从页面移除</td><td>无</td><td>清理仍在等待的 timer（若存在）</td></tr></tbody></table><p>你会看到一个固定顺序：</p><ol><li>状态变化触发渲染</li><li>渲染完成后，检查依赖是否变化</li><li>若变化：先跑上一次 cleanup，再跑这一次 setup</li></ol><p>Java 类比：像“监听器重注册”流程——先 <code>remove old listener</code>，再 <code>add new listener</code>，避免重复订阅和资源泄漏。</p><h3 id="_8-2-为什么一定要-cleanup" tabindex="-1"><a class="header-anchor" href="#_8-2-为什么一定要-cleanup"><span>8.2 为什么一定要 cleanup</span></a></h3><p>如果不 cleanup，定时器会越积越多：</p><ul><li>输入 <code>ja</code> 时开一个 timer</li><li>输入 <code>jav</code> 又开一个 timer</li><li>输入 <code>java</code> 再开一个 timer</li></ul><p>最终会出现多次重复请求、旧结果覆盖新结果、资源浪费。</p><h3 id="_8-3-依赖数组语义-速记" tabindex="-1"><a class="header-anchor" href="#_8-3-依赖数组语义-速记"><span>8.3 依赖数组语义（速记）</span></a></h3><ul><li><code>[]</code>：仅首次挂载执行一次</li><li><code>[dep]</code>：挂载后执行 + <code>dep</code> 变化时再执行</li><li>不写依赖：每次渲染都执行（通常不推荐）</li></ul><p>Java 类比：<code>useEffect</code> 不是单纯“生命周期函数”，更像“依赖驱动的回调 + 自动清理器”。</p><hr><h2 id="_9-useref-保存-可变容器" tabindex="-1"><a class="header-anchor" href="#_9-useref-保存-可变容器"><span>9. <code>useRef</code>：保存“可变容器”</span></a></h2><p><code>useRef</code> 常用于两类场景：</p><ol><li>获取 DOM 或第三方实例引用</li><li>保存不需要触发渲染的可变值</li></ol><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>import</span><span class="space"> </span><span>{</span><span class="space"> </span><span>useRef</span><span class="space"> </span><span>}</span><span class="space"> </span><span>from</span><span class="space"> </span><span>&quot;react&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const</span><span class="space"> </span><span>inputRef</span><span class="space"> </span><span>=</span><span class="space"> </span><span>useRef&lt;HTMLInputElement</span><span class="space"> </span><span>|</span><span class="space"> </span><span>null&gt;(null);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function</span><span class="space"> </span><span>focusInput()</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>inputRef.current?.focus();</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：修改 <code>ref.current</code> 不会触发重渲染。</p><hr><h2 id="_10-usememo-与-usecallback-控制不必要计算和渲染" tabindex="-1"><a class="header-anchor" href="#_10-usememo-与-usecallback-控制不必要计算和渲染"><span>10. <code>useMemo</code> 与 <code>useCallback</code>：控制不必要计算和渲染</span></a></h2><ul><li><code>useMemo</code>：缓存“值”</li><li><code>useCallback</code>：缓存“函数”</li></ul><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>import</span><span class="space"> </span><span>{</span><span class="space"> </span><span>useCallback,</span><span class="space"> </span><span>useMemo</span><span class="space"> </span><span>}</span><span class="space"> </span><span>from</span><span class="space"> </span><span>&quot;react&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const</span><span class="space"> </span><span>total</span><span class="space"> </span><span>=</span><span class="space"> </span><span>useMemo(()</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>heavyCompute(list),</span><span class="space"> </span><span>[list]);</span></span>
<span class="line"><span>const</span><span class="space"> </span><span>onSelect</span><span class="space"> </span><span>=</span><span class="space"> </span><span>useCallback((id:</span><span class="space"> </span><span>string)</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>doSomething(id),</span><span class="space"> </span><span>[doSomething]);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原则：</p><ul><li>先保证正确，再做优化。</li><li>不要为“看起来高级”而滥用。</li></ul><hr><h2 id="_11-组件复用与组合" tabindex="-1"><a class="header-anchor" href="#_11-组件复用与组合"><span>11. 组件复用与组合</span></a></h2><p>React 推荐“组合优于继承”。常见方式：</p><h3 id="_11-1-children-插槽" tabindex="-1"><a class="header-anchor" href="#_11-1-children-插槽"><span>11.1 <code>children</code> 插槽</span></a></h3><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>import</span><span class="space"> </span><span>type</span><span class="space"> </span><span>{</span><span class="space"> </span><span>ReactNode</span><span class="space"> </span><span>}</span><span class="space"> </span><span>from</span><span class="space"> </span><span>&quot;react&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>type</span><span class="space"> </span><span>PanelProps</span><span class="space"> </span><span>=</span><span class="space"> </span><span>{</span><span class="space"> </span><span>title:</span><span class="space"> </span><span>string;</span><span class="space"> </span><span>children:</span><span class="space"> </span><span>ReactNode</span><span class="space"> </span><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function</span><span class="space"> </span><span>Panel({</span><span class="space"> </span><span>title,</span><span class="space"> </span><span>children</span><span class="space"> </span><span>}:</span><span class="space"> </span><span>PanelProps)</span><span class="space"> </span><span>{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>return</span><span class="space"> </span><span>(</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;section&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;h3&gt;{title}&lt;/h3&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;div&gt;{children}&lt;/div&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span>&lt;/section&gt;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span>);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_11-2-业务逻辑抽成自定义-hook" tabindex="-1"><a class="header-anchor" href="#_11-2-业务逻辑抽成自定义-hook"><span>11.2 业务逻辑抽成自定义 Hook</span></a></h3><p>当多个组件共享同一套状态逻辑时，用 <code>useXxx</code> 提炼。</p><hr><h2 id="_12-受控组件与表单思维" tabindex="-1"><a class="header-anchor" href="#_12-受控组件与表单思维"><span>12. 受控组件与表单思维</span></a></h2><p>受控组件：输入值由 React state 驱动。</p><div class="language-tsx line-numbers-mode" data-ext="tsx" data-title="tsx"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki one-dark-pro vp-code"><code><span class="line"><span>const</span><span class="space"> </span><span>[name,</span><span class="space"> </span><span>setName]</span><span class="space"> </span><span>=</span><span class="space"> </span><span>useState(&quot;&quot;);</span></span>
<span class="line"><span>&lt;input</span><span class="space"> </span><span>value={name}</span><span class="space"> </span><span>onChange={(e)</span><span class="space"> </span><span>=&gt;</span><span class="space"> </span><span>setName(e.target.value)}</span><span class="space"> </span><span>/&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>好处：</p><ul><li>数据流可控</li><li>便于校验、联动、提交</li></ul><hr><h2 id="_13-数据流-单向数据流是-react-的核心原则" tabindex="-1"><a class="header-anchor" href="#_13-数据流-单向数据流是-react-的核心原则"><span>13. 数据流：单向数据流是 React 的核心原则</span></a></h2><p>父组件通过 props 向下传递数据，子组件通过回调把事件向上传递。</p><p>典型模式：</p><ol><li>父组件保存状态</li><li>子组件渲染 props</li><li>子组件触发事件回调</li><li>父组件更新状态并重新下发 props</li></ol><p>这个“自上而下”的流向，让组件行为更可预测。</p><p>Java 类比：父组件像上层 Service/Controller，子组件像被调用方；数据向下传，事件通过回调向上抛，避免跨层随意改状态。</p><hr><h2 id="_14-java-与-react-对照速查表" tabindex="-1"><a class="header-anchor" href="#_14-java-与-react-对照速查表"><span>14. Java 与 React 对照速查表</span></a></h2><table><thead><tr><th>React 概念</th><th>Java 工程师可类比</th><th>关键差异</th></tr></thead><tbody><tr><td>组件（Component）</td><td>类 + <code>render()</code></td><td>React 由状态变化自动触发渲染</td></tr><tr><td><code>props</code></td><td>方法参数 / 构造参数</td><td><code>props</code> 在组件内部应只读</td></tr><tr><td><code>state</code></td><td>类的成员变量</td><td>需通过 <code>setXxx</code> 更新才能刷新 UI</td></tr><tr><td><code>useEffect</code></td><td>生命周期回调 + 监听器</td><td>依赖变化会重复执行，并支持清理</td></tr><tr><td><code>useRef</code></td><td>成员变量引用</td><td>改 <code>ref.current</code> 不触发重渲染</td></tr><tr><td><code>useMemo</code></td><td>缓存计算结果</td><td>仅性能优化，不改变业务语义</td></tr></tbody></table><hr><h2 id="_15-函数式组件常见误区" tabindex="-1"><a class="header-anchor" href="#_15-函数式组件常见误区"><span>15. 函数式组件常见误区</span></a></h2><ol><li><code>useEffect</code> 依赖漏写，造成闭包旧值问题。</li><li>把所有数据都放全局状态，导致复杂度上升。</li><li>直接修改 state 对象/数组，导致视图不更新。</li><li>列表渲染使用不稳定 key，导致渲染异常。</li><li>为了优化而过度使用 <code>useMemo/useCallback</code>。</li></ol><hr><h2 id="_16-一句话总结" tabindex="-1"><a class="header-anchor" href="#_16-一句话总结"><span>16. 一句话总结</span></a></h2><p>函数式组件的核心是：</p><ul><li>用 props 描述输入</li><li>用 state 管理变化</li><li>用 effect 处理副作用</li><li>用组合与 Hook 复用逻辑</li><li>用单向数据流保持可预测</li></ul><p>把这五点真正理解透，你就掌握了 React 组件基础的主干。</p>`,153)])])}const d=a(c,[["render",l]]),o=JSON.parse(`{"path":"/article/j3yf2tp3/","title":"React 组件基础","lang":"zh-CN","frontmatter":{"title":"React 组件基础","createTime":"2026/02/09 15:51:41","permalink":"/article/j3yf2tp3/","description":"1. 组件是什么 在 React 里，组件（Component）是 UI 的最小可复用单元。你可以把页面看成组件树： 页面组件负责整体结构 业务组件负责某个功能块 通用组件负责复用能力（弹窗、表格、按钮、加载态等） 组件化的意义是：拆分复杂度、提高复用率、降低维护成本。 Java 工程师可先这样理解 React 组件 ≈ Java 里的“对象 + re...","head":[["meta",{"property":"og:url","content":"https://callmeexiao.baby/article/j3yf2tp3/"}],["meta",{"property":"og:site_name","content":"Exiao's Blog"}],["meta",{"property":"og:title","content":"React 组件基础"}],["meta",{"property":"og:description","content":"1. 组件是什么 在 React 里，组件（Component）是 UI 的最小可复用单元。你可以把页面看成组件树： 页面组件负责整体结构 业务组件负责某个功能块 通用组件负责复用能力（弹窗、表格、按钮、加载态等） 组件化的意义是：拆分复杂度、提高复用率、降低维护成本。 Java 工程师可先这样理解 React 组件 ≈ Java 里的“对象 + re..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2026-02-09T09:37:46.000Z"}],["meta",{"property":"article:modified_time","content":"2026-02-09T09:37:46.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React 组件基础\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2026-02-09T09:37:46.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":9.77,"words":2931},"git":{"updatedTime":1770629866000,"contributors":[{"name":"金逸霄","username":"金逸霄","email":"yixiaojin@ptkj.net","commits":1,"avatar":"https://avatars.githubusercontent.com/金逸霄?v=4","url":"https://github.com/金逸霄"}]},"autoDesc":true,"filePathRelative":"前端技术/React 组件基础.md","categoryList":[{"id":"40d75c","sort":10003,"name":"前端技术"}]}`);export{d as comp,o as data};
